<!DOCTYPE html>
<html  lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
      <title>nats.aio.subscription</title>
    
          <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../../_static/doctools.js?v=9bcbadda"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../../../_static/theme-vendors.js"></script> -->
      <script src="../../../_static/theme.js" defer></script>
    
  <link rel="index" title="Index" href="../../../genindex.html" />
  <link rel="search" title="Search" href="../../../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../../../index.html" class="home-link">
    
      <img class="logo" src="../../../../../../_static/nats-icon-color.png" alt="logo"/>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



  
    <div class="nav-item">
      <a href="https://github.com/nats-io/nats.py"
        class="nav-link external">
          Github <outboundlink></outboundlink>
      </a>
    </div>
  
    <div class="nav-item">
      <a href="https://nats.io"
        class="nav-link external">
          NATS <outboundlink></outboundlink>
      </a>
    </div>
  

    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



  
    <div class="nav-item">
      <a href="https://github.com/nats-io/nats.py"
        class="nav-link external">
          Github <outboundlink></outboundlink>
      </a>
    </div>
  
    <div class="nav-item">
      <a href="https://nats.io"
        class="nav-link external">
          NATS <outboundlink></outboundlink>
      </a>
    </div>
  

            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">Quick search</span>
    <div class="searchformwrapper">
      <form class="search" action="../../../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="Search" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../../index.html#getting-started">Documentation</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../../../modules.html" class="reference internal ">Modules</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../../../releases.html" class="reference internal ">Releases</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
    
      <li><a href="../../index.html">Module code</a> &raquo;</li>
    
      <li><a href="../../nats.html">nats</a> &raquo;</li>
    
    <li>nats.aio.subscription</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <h1>Source code for nats.aio.subscription</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2016-2021 The NATS Authors</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1"># http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1">#</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">AsyncIterator</span><span class="p">,</span>
    <span class="n">Awaitable</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">uuid</span> <span class="kn">import</span> <span class="n">uuid4</span>

<span class="kn">from</span> <span class="nn">nats</span> <span class="kn">import</span> <span class="n">errors</span>
<span class="c1"># Default Pending Limits of Subscriptions</span>
<span class="kn">from</span> <span class="nn">nats.aio.msg</span> <span class="kn">import</span> <span class="n">Msg</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">nats.js</span> <span class="kn">import</span> <span class="n">JetStreamContext</span>

<span class="n">DEFAULT_SUB_PENDING_MSGS_LIMIT</span> <span class="o">=</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">1024</span>
<span class="n">DEFAULT_SUB_PENDING_BYTES_LIMIT</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>


<div class="viewcode-block" id="Subscription">
<a class="viewcode-back" href="../../../modules.html#nats.aio.subscription.Subscription">[docs]</a>
<span class="k">class</span> <span class="nc">Subscription</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Subscription represents interest in a particular subject.</span>

<span class="sd">    A Subscription should not be constructed directly, rather</span>
<span class="sd">    `connection.subscribe()` should be used to get a subscription.</span>

<span class="sd">    ::</span>

<span class="sd">        nc = await nats.connect()</span>

<span class="sd">        # Async Subscription</span>
<span class="sd">        async def cb(msg):</span>
<span class="sd">          print(&#39;Received&#39;, msg)</span>
<span class="sd">        await nc.subscribe(&#39;foo&#39;, cb=cb)</span>

<span class="sd">        # Sync Subscription</span>
<span class="sd">        sub = nc.subscribe(&#39;foo&#39;)</span>
<span class="sd">        msg = await sub.next_msg()</span>
<span class="sd">        print(&#39;Received&#39;, msg)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">conn</span><span class="p">,</span>
        <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">subject</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="n">queue</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
        <span class="n">cb</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Msg</span><span class="p">],</span> <span class="n">Awaitable</span><span class="p">[</span><span class="kc">None</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">future</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_msgs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">pending_msgs_limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">DEFAULT_SUB_PENDING_MSGS_LIMIT</span><span class="p">,</span>
        <span class="n">pending_bytes_limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">DEFAULT_SUB_PENDING_BYTES_LIMIT</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span> <span class="o">=</span> <span class="n">conn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subject</span> <span class="o">=</span> <span class="n">subject</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span> <span class="o">=</span> <span class="n">queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_msgs</span> <span class="o">=</span> <span class="n">max_msgs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_received</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cb</span> <span class="o">=</span> <span class="n">cb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_future</span> <span class="o">=</span> <span class="n">future</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Per subscription message processor.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pending_msgs_limit</span> <span class="o">=</span> <span class="n">pending_msgs_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pending_bytes_limit</span> <span class="o">=</span> <span class="n">pending_bytes_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pending_queue</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">[</span><span class="n">Msg</span><span class="p">]</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span>
            <span class="n">maxsize</span><span class="o">=</span><span class="n">pending_msgs_limit</span>
        <span class="p">)</span>
        <span class="c1"># If no callback, then this is a sync subscription which will</span>
        <span class="c1"># require tracking the next_msg calls inflight for cancelling.</span>
        <span class="k">if</span> <span class="n">cb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pending_next_msgs_calls</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pending_next_msgs_calls</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pending_size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_msgs_task</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_message_iterator</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># For JetStream enabled subscriptions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jsi</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">JetStreamContext</span><span class="o">.</span><span class="n">_JSI</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">subject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the subject of the `Subscription`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subject</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">queue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the queue name of the `Subscription` if part of a queue group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">messages</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">Msg</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves an async iterator for the messages from the subscription.</span>

<span class="sd">        This is only available if a callback isn&#39;t provided when creating a</span>
<span class="sd">        subscription.</span>

<span class="sd">        ::</span>
<span class="sd">    </span>
<span class="sd">            nc = await nats.connect()</span>
<span class="sd">            sub = await nc.subscribe(&#39;foo&#39;)</span>
<span class="sd">            # Use `async for` which implicitly awaits messages</span>
<span class="sd">            async for msg in sub.messages:</span>
<span class="sd">                print(&#39;Received&#39;, msg)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_message_iterator</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span>
                <span class="s2">&quot;cannot iterate over messages with a non iteration subscription type&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_message_iterator</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pending_msgs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of delivered messages by the NATS Server that are being buffered</span>
<span class="sd">        in the pending queue.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_queue</span><span class="o">.</span><span class="n">qsize</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pending_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Size of data sent by the NATS Server that is being buffered</span>
<span class="sd">        in the pending queue.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">delivered</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of delivered messages to this subscription so far.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_received</span>

<div class="viewcode-block" id="Subscription.next_msg">
<a class="viewcode-back" href="../../../modules.html#nats.aio.subscription.Subscription.next_msg">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">next_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Msg</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :params timeout: Time in seconds to wait for next message before timing out.</span>
<span class="sd">        :raises nats.errors.TimeoutError:</span>

<span class="sd">        next_msg can be used to retrieve the next message from a stream of messages using</span>
<span class="sd">        await syntax, this only works when not passing a callback on `subscribe`::</span>

<span class="sd">            sub = await nc.subscribe(&#39;hello&#39;)</span>
<span class="sd">            msg = await sub.next_msg(timeout=1)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">ConnectionClosedError</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cb</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span>
                <span class="s1">&#39;nats: next_msg cannot be used in async subscriptions&#39;</span>
            <span class="p">)</span>

        <span class="n">task_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid4</span><span class="p">())</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">future</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
                <span class="n">asyncio</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pending_queue</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">timeout</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pending_next_msgs_calls</span><span class="p">[</span><span class="n">task_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">future</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="k">await</span> <span class="n">future</span>
        <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">TimeoutError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">ConnectionClosedError</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">TimeoutError</span>
        <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">ConnectionClosedError</span>
            <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pending_size</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="c1"># For sync subscriptions we will consider a message</span>
            <span class="c1"># to be done once it has been consumed by the client</span>
            <span class="c1"># regardless of whether it has been processed.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pending_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">msg</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pending_next_msgs_calls</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">task_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_cb</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the resources for the subscription to start processing messages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cb</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cb</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cb</span><span class="p">,</span> <span class="s2">&quot;func&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">iscoroutinefunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cb</span><span class="o">.</span><span class="n">func</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span>
                    <span class="s2">&quot;nats: must use coroutine for subscriptions&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_msgs_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_msgs</span><span class="p">(</span><span class="n">error_cb</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_future</span><span class="p">:</span>
            <span class="c1"># Used to handle the single response from a request.</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_message_iterator</span> <span class="o">=</span> <span class="n">_SubscriptionMessageIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Subscription.drain">
<a class="viewcode-back" href="../../../modules.html#nats.aio.subscription.Subscription.drain">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">drain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes interest in a subject, but will process remaining messages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">ConnectionClosedError</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">is_draining</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">ConnectionDrainingError</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">BadSubscriptionError</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_drain</span><span class="p">()</span></div>


    <span class="k">async</span> <span class="k">def</span> <span class="nf">_drain</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Announce server that no longer want to receive more</span>
            <span class="c1"># messages in this sub and just process the ones remaining.</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">_send_unsubscribe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>

            <span class="c1"># Roundtrip to ensure that the server has sent all messages.</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_queue</span><span class="p">:</span>
                <span class="c1"># Wait until no more messages are left,</span>
                <span class="c1"># then cancel the subscription task.</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_queue</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

            <span class="c1"># stop waiting for messages</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stop_processing</span><span class="p">()</span>

            <span class="c1"># Subscription is done and won&#39;t be receiving further</span>
            <span class="c1"># messages so can throw it away now.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">_remove_sub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Subscription.unsubscribe">
<a class="viewcode-back" href="../../../modules.html#nats.aio.subscription.Subscription.unsubscribe">[docs]</a>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">unsubscribe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param limit: Max number of messages to receive before unsubscribing.</span>

<span class="sd">        Removes interest in a subject, remaining messages will be discarded.</span>

<span class="sd">        If `limit` is greater than zero, interest is not immediately removed,</span>
<span class="sd">        rather, interest will be automatically removed after `limit` messages</span>
<span class="sd">        are received.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">is_closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">ConnectionClosedError</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">is_draining</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">ConnectionDrainingError</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">BadSubscriptionError</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_max_msgs</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_received</span> <span class="o">&gt;=</span> <span class="n">limit</span>
                          <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_queue</span><span class="o">.</span><span class="n">empty</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stop_processing</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">_remove_sub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">is_reconnecting</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn</span><span class="o">.</span><span class="n">_send_unsubscribe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_stop_processing</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stops the subscription from processing new messages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_msgs_task</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_msgs_task</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_msgs_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_message_iterator</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_message_iterator</span><span class="o">.</span><span class="n">_cancel</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_wait_for_msgs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_cb</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A coroutine to read and process messages if a callback is provided.</span>

<span class="sd">        Should be called as a task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cb</span><span class="p">,</span> <span class="s2">&quot;_wait_for_msgs can be called only from _start&quot;</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_pending_size</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Invoke depending of type of handler.</span>
                    <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cb</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
                    <span class="c1"># In case the coroutine handler gets cancelled</span>
                    <span class="c1"># then stop task loop and return.</span>
                    <span class="k">break</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="c1"># All errors from calling a handler</span>
                    <span class="c1"># are async errors.</span>
                    <span class="k">if</span> <span class="n">error_cb</span><span class="p">:</span>
                        <span class="k">await</span> <span class="n">error_cb</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="c1"># indicate the message finished processing so drain can continue.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_pending_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>

                <span class="c1"># Apply auto unsubscribe checks after having processed last msg.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_msgs</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_received</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_msgs</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pending_queue</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_stop_processing</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">CancelledError</span><span class="p">:</span>
                <span class="k">break</span></div>



<span class="k">class</span> <span class="nc">_SubscriptionMessageIterator</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub</span><span class="p">:</span> <span class="n">Subscription</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sub</span><span class="p">:</span> <span class="n">Subscription</span> <span class="o">=</span> <span class="n">sub</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">[</span><span class="n">Msg</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">_pending_queue</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unsubscribed_future</span><span class="p">:</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unsubscribed_future</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unsubscribed_future</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_SubscriptionMessageIterator</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">async</span> <span class="k">def</span> <span class="fm">__anext__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Msg</span><span class="p">:</span>
        <span class="n">get_task</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_running_loop</span><span class="p">()</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
        <span class="n">tasks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_task</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unsubscribed_future</span><span class="p">]</span>
        <span class="n">finished</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span>
            <span class="n">tasks</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">asyncio</span><span class="o">.</span><span class="n">FIRST_COMPLETED</span>
        <span class="p">)</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sub</span>

        <span class="k">if</span> <span class="n">get_task</span> <span class="ow">in</span> <span class="n">finished</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">get_task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sub</span><span class="o">.</span><span class="n">_pending_size</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

            <span class="c1"># Unblock the iterator in case it has already received enough messages.</span>
            <span class="k">if</span> <span class="n">sub</span><span class="o">.</span><span class="n">_max_msgs</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">sub</span><span class="o">.</span><span class="n">_received</span> <span class="o">&gt;=</span> <span class="n">sub</span><span class="o">.</span><span class="n">_max_msgs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cancel</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">msg</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unsubscribed_future</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="n">get_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

        <span class="k">raise</span> <span class="ne">StopAsyncIteration</span>
</pre></div>

          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; Copyright 2021-2024, The NATS Authors.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 8.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.9.1.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>